/*
In the service worker install event, we first open the cache with the
 caches.open() method, then we use fetch() to get the asset-manifest.json
  file thatâ€™s generated by WebPack to map hashed assets to their original
  names. Next, we invoke cache.addAll() to add these assets to the
  application cache:
*/

self.addEventListener('install', function(event) {
    event.waitUntil(
      caches.open('react-pwa-v1')
        .then(function(cache) {
          // The asset-manifest.json contains the names of assets to cache
          fetch("asset-manifest.json")
            .then(response => {
              return response.json()
            })
            .then(assets => {

              cache.addAll(
                [
                  "/",
                  "https://fonts.googleapis.com/css?family=Roboto:300,400,500",
                  assets["main.js"],
                  assets["main.css"],
                  assets["static/media/logo.svg"]
                ]
              );

            })
        })
    );
});


/*
This code intercepts every network request by listening to the fetch event
and responding with the cached response if it exists in the application cache
(using the caches.match() method). Otherwise, we normally call fetch()
 to get the asset:
*/
// Serves the cached response for the corresponding request
self.addEventListener('fetch', function(event) {
    event.respondWith(
          caches.match(event.request).then(function(response) {
              if(response) return response;
              return fetch(event.request);
          })
    );
});

/*
When the app is activated, we delete the old cache if different from
the current one.
*/
self.addEventListener("activate", event => {
  event.waitUntil(
    caches.keys()
      .then(keys =>
        Promise.all(keys.map(key => {
          if (key !== 'react-pwa-v1') {
            return caches.delete(key);
          }
        }))
      )
  );
});
